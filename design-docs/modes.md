# Summary

This document describes a standardized approach for operators to select different code to run for different robot modes of operation and for programmers to easily write code that creates these selection options.

A note on terminology: the word "mode" is used in this document to describe this functionality.  While this word overlaps with the more general "modes" of robot operation (e.g. disabled, periodic, and auto), it's natural to describe the robot as having "several autonomous modes" and "in autonomous mode" (without referring to a specific one) refers to the general robot mode.

# Motivation

Operator selection of different code implementing unique top-level robot behavior–without recompilation of the robot program–is a very common need across most FTC and FRC teams, so it’s desirable to have a standardized approach for cleanly structuring robot code to support this, along with integrated support for selection at the Driver Station.

Primary use cases for operator-selectable code include:

- Multiple autonomous routines (e.g. following different paths, performing different actions)

- Different teleoperated behavior (e.g. tank vs arcade drive, different button mappings, operating restrictions for robot demonstrations/guest drivers)

- Testing (e.g. testing of the whole robot or a single subsystem, sensor, or motor)

Notably these use cases span both matches and off-field testing.

Secondarily, some teams may want to use different code structures for different use cases (e.g. linear for autonomous and iterative for test or teleop; or command-based for autonomous and teleop and linear tests).

# Background

Both FTC and FRC historically have had at least some level of support for operator selection of code, but the approaches used and resulting functionality and behaviors are quite different.  To provide context and background driving the design decisions in this document, a summary of these behaviors (as of 2025) is provided in this section.

## FRC

### Core concepts

- The robot has 3 fixed system-level modes of operation: autonomous, teleoperated, and test
- The robot is in either enabled (actuators enabled) or disabled (actuators disabled) state
- In competition matches, the FMS automatically transitions between autonomous, disabled, and teleoperated modes
- Robot code is structured around a top-level Robot class that instantiates the hardware objects as member variables (often organized into subsystem objects stored as members) and functions that run in each robot mode; the library robot base class handles calling these functions as directed by the DS
- Selection of different user code routines within these system-level modes (e.g. multiple autonomous routines) is usually performed using a separate dashboard application
- In robot code, the selection list is generated by user code instantiating a utility class called `SendableChooser`, adding options to it with function calls during initialization, and calling a function to get the selected option at the appropriate time

### Driver Station

When not connected to the Field Management System (FMS), the [FRC driver station application](https://docs.wpilib.org/en/stable/docs/software/driverstation/driver-station.html) provides the operator a fixed selection of 4 different modes of robot operation (teleoperated, autonomous, test, and practice) and buttons to enable and disable the robot.  In three of these modes (teleoperated, autonomous, and test), selecting a mode and enabling the robot immediately starts code execution for that mode for an unlimited amount of time (until the user disables the robot).  The "practice" mode provides for off-field testing of match behavior by mimicing match behavior (automatically transitioning disabled->auto->disabled->teleop->disabled with pre-configured durations for each step).

![Driver Station GUI](https://docs.wpilib.org/en/stable/_images/ds-operation-tab.webp)

All actuators are disabled at all times the robot is disabled.  The robot starts in disabled state (prior to receiving driver station packets) and the only way to enable the robot is via the driver station.  Any loss of communication results in the robot transitioning back to disabled state.  Similarly, the driver station starts in disabled state and automatically transitions to disabled state when communication is lost.

In autonomous mode, joystick inputs from the Driver Station are not passed to the robot; values are latched at the last state before entering autonomous mode.  Joystick inputs are sent to the robot in all other modes, including disabled.

When a match starts, the FMS commands the driver station to enable the robot in autonomous mode for the autonomous period, followed by a short time disabled (typically 1-3 seconds), followed by enabling the robot in teleoperated mode for the teleoperated period, followed by disable.

Separate from the driver station application, WPILib-provided as well as custom dashboard applications are commonly utilized by teams to provide a drop-down list for selection of autonomous routines.  Operators select the desired autonomous routine via the dashboard prior to the start of a match (or off-field testing of autonomous).  Some teams use other methods to select different autonomous routines (e.g. physical jumpers on the robot, using joystick inputs while the robot is disabled), but the dashboard method is the standard approach.

### Robot Code

The standard WPILib team code structure derives a single team-written `Robot` class from an "periodic" robot base class.  This `Robot` class is constructed and run by the Java `main()` function.  After construction, the base class implementation runs a periodic loop (typically running on a 20 ms period, although that can be changed by the user) that reads the enabled state and teleop/auto/test mode provided by the DS and calls virtual functions for each mode (disabled, teleop, auto, and test), as well as a `robotPeriodic` virtual function that is always called regardless of mode.  Three virtual functions are provided for each mode: an init function (called when the mode is transitioned into from another mode), a periodic function (called on a fixed period), and an exit function (called when the mode is transitioned out of into another mode).  Teams override these functions in their Robot derived class to implement their robot code.  Because of this code structure, teams generally create their hardware configuration (can be flat or organized into subsystems) and other objects as member variables within the Robot class (constructed at robot start) and share them across all modes of operation.

WPILib provides a class called `SendableChooser` for creating the drop-down lists shown on the dashboard.  This class is a generic/template class that provides a map of string key (shown on the drop-down) and object value (read by robot code).  This is typically displayed by dashboards as a simple list with no categorization.  This feature is most often used by teams for autonomous routine selection, but is not limited to that use case.  Examples and templates show teams how to instantiate this class, add it to the dashboard, and use it for operator selection of different autonomous routines (by reading the chosen value from the object and executing different code).  Examples of how to use `SendableChooser` for operator selection in other modes (e.g. teleop or test) is not provided, and it's generally uncommon for teams to use it in that way–most team code has just a single teleop routine, and the test mode is rarely used (manual testing code is instead usually integrated as part of the teleop routine).

A significant portion of FRC teams use the command-based framework, which builds on top of the periodic model with the concepts of subsystems and commands and a scheduler that provides cooperative multitasking. Subsystem objects are typically member variables of the `Robot` class (or a separate class called `RobotContainer`), and command objects are created and bound to joystick buttons or other triggers during construction.  In this code model, most behaviors are modeled as commands configured during robot construction, and very little is done explicitly iteratively.  Subsystems have a standardized `periodic()` method that is called by the command scheduler, which is most often used for telemetry.  In the provided template code, the command scheduler is set up to run in all modes because it is called by the `robotPeriodic()` method.  Triggers can be configured to run specific commands at the start of disabled/teleop/auto/test modes.  Operator selection of autonomous is still done via `SendableChooser`, with the `SendableChooser` value usually being a `Command` that is started when the auto mode is started.  Notably, this model shares both subsystems and command implementations between all operational modes–only the commands that are being run change; in general this has been seen as a benefit because it enables reuse (e.g. a "set elevator to height" command is useful in both autonomous and teleoperated modes, and a subsystem operates fundamentally the same in both modes).

Historically, WPILib offered a "simple" (later renamed to "sample") robot base class that had single virtual functions for teleop, auto, and test, with no outer periodic loop (the user was responsible for writing the loop).  This was deprecated and removed circa 2016 as it was common to see teams writing autonomous loops or sleeps without proper exit condition checking (e.g. wait for the robot to drive X feet), resulting in the robot code never exiting autonomous and thus not transitioning to teleoperated in matches.  After removal of this template, this relatively common issue has entirely disappeared.

## FTC

### Core concepts

- Robot programs are structured around the concept of "opmodes"; there are two *types* of opmodes: teleoperated and autonomous
- In competition matches, operators manually operate the DS to start the autonomous and teleoperated periods (there is no FMS)
- Selection of opmodes is fully integrated into the DS; an opmode must be selected before Init is pressed
- The DS has a three-step manual process for running robot code: select the opmode, press Init (robot enabled, opmode constructed, opmode `init()` called), press Play (opmode `run()` or equivalent called)
- In robot code, opmodes are represented by users creating individual annotated classes; a library opmode manager handles generation of the opmode selection list (by scanning for annotated classes) and instantiating and calling class functions as directed by the DS
- Hardware objects are created by the library based on an XML file; opmodes read this map to get access to the objects

### Driver Station

Opmodes are presented in the DS as a selectable list containing both auto and teleop opmodes.  Opmode selection on the DS is just UI candy; the robot knows nothing about what the operator has done until Init is pressed, at which point the opmode is communicated to the robot and the robot is enabled.  If an auto op mode is selected, an additional button appears that allows the operator to pre-select a teleop op mode. This eases the match transition between auto and teleop, but it's still necessary for the operator to manually press Init and Play buttons to start the teleop mode.

![FTC DS OpMode Selection Screen](https://github.com/FIRST-Tech-Challenge/FtcRobotController/wiki/images/Automatically-Loading-a-Driver-Controlled-Op-Mode/selectTeleOp.png)

The robot actuators are enabled as soon as the Init button is pressed.  Pressing the Play button starts OpMode execution.  Pressing the Stop button (shown after Init is pressed) disables the robot.

Auto modes by default stop/disable after 30 seconds, but this can be turned off for non-competition use.

### Robot Code

FTC robot programs are structured around the concept of "opmodes."  Opmodes are user classes that are registered as either teleoperated or autonomous opmodes using Java annotations.  Several different opmode base class options are available, including a "linear" opmode that provides a single function (and the user is responsible for the loop) and an "iterative" opmode that calls a single function periodically.

The library contains an opmode manager that is responsible for registering and switching between opmodes based on operator input.  The switching is generally done cooperatively, but if an opmode fails to return within a reasonable amount of time, several increasing steps are taken to try to get it to exit; if ultimately the opmode does not exit, the entire robot executable is terminated (and automatically restarted).

Opmode classes are constructed when the user taps the Init button in the DS.  This works because hardware initialization processes never take more than a few seconds, and there's always a human lag between tapping Init and tapping Start.

Hardware configuration is stored in an xml file that is consumed on APK startup, or when a different configuration is selected by the operator.  Consuming the xml file instantiates all objects (sensors, motors, servos, etc...) and stores them in a dictionary.  This dictionary then persists until either the robot is power cycled, or the operator selects a different configuration.  User code pulls items out of the dictionary, typically in an initialization portion of an opmode, and then use throughout the opmode.  Notably, when the opmode finishes, or is stopped, the dictionary persists.

As opmodes are separate classes and there is no top-level robot class in the standard template, sharing state between opmodes is often a challenge for teams.

The Java annotation-based registration approach allows for specifying a string name for the opmode (displayed on the DS); this is automatically generated from the class name if none is provided.  The annotation also allows specifying a string group name; this is used to provide display grouping of the opmodes at the DS.  Two annotations are used to separately register autonomous and teleop opmodes to filter the displayed lists on the DS for each mode.  Additionally, opmodes may be disabled through the use of an additional `@Disabled` annotation; these are hidden from the DS displayed list.

# Requirements and Desirable Features

For competition, matches usually consist of an autonomous period followed by a teleoperated period.  FTC and FRC currently have different amounts of operator interaction.  In FRC, the time period between auto and teleop is very short (can be <1 second some years), and so it's a requirement for FRC that both the auto and teleop modes be able to be pre-selected by the operator prior to the start of the match, and for the DS to handle automatically transitioning between these modes.  In FTC, there is currently no FMS, and so a longer delay between auto and teleop is common to allow teams to pick up controllers, but pre-selecting a teleop mode enables a more efficient transition to teleop, so having this feature benefits FTC use cases as well.

It is not a requirement to support different programming languages for different operator-selectable modes (e.g. auto in Python, teleop in Java). Supporting this would require completely terminating the robot executable and starting a new robot executable (and re-initializing all the hardware), which can take a substantial and variable amount of time to complete. This is very undesirable for FRC due to the short transition from auto to teleop; although it's less problematic for FTC, it makes sharing state between modes essentially impossible, and sharing hardware configurations is also difficult.

Similarly, it is not a requirement to support running the same robot project on entirely different physical robots.  That situation is better handled through entirely separate robot projects that define the unique hardware configuration.

A clear enable/disable in the Driver Station that disables all robot actuators when disabled is a requirement because it is a safety-critical feature for FRC due to the size and power of FRC robots.

The enabled "Init" step in the 2025 FTC SDK/DS is not a requirement due to anticipated rule changes.  However, performing initialization of modes while the robot is still disabled is a requirement for both FTC and FRC, as it's important for user code to be able to do expensive mode-specific operations (e.g. computing autonomous paths) prior to actually starting the match.

Providing the top-level teleop, autonomous, and test selection available in the 2015 FRC driver station is desirable and has few downsides for either program.  In combination with code specifying the applicable modes (also desirable), this allows for filtering down of selectable modes.  The "practice" mode feature of the 2015 FRC driver station which automatically transitions between modes based on time is a very useful tool for teams to simulate match transitions at home and should be retained, but should be renamed to reduce confusion, particularly as this mode is likely to be used for FTC matches without a FMS, "match" mode could be a good name for this feature.

# Design

## Overview / Key Features

- DS provides a prominent enable/disable state control and a teleop/auto/test/match selector.  For teleop/auto/test, enabling the robot immediately starts execution of the selected mode; in match mode, a match sequence is followed (auto mode followed by a disabled delay, followed by teleop mode).

- DS provides drop-down selector(s) for the user-defined modes; these are filtered based on the top-level mode selector (e.g. if auto is selected, a single drop-down selector of just the auto modes is provided).  For match mode or when FMS-attached, two drop downs are provided (one for auto mode selection and one for teleop mode selection).  The drop-down selector provides grouped categories as specified by the robot program.

- Robot programs are structured to have a top-level Robot class (e.g. motors/sensors/subsystems); this is also where robot-wide initialization is performed (in the class constructor or static initializer block).  The Robot class provides virtual periodic type functions for users to run code when the robot is disabled.

- Modes are usually registered via annotation of classes.  These annotations may specify a name (or default to the class name), group name (for grouping of routines in the selection list), and description.  Annotations are used to specify whether the class is a teleop, auto, or test mode.

- Routines may also be registered via annotation of functions (in the Robot class only) or via explicit function calls.  As C++ does not support annotations, function call registration is the only available method in that language.

- For maximum flexibility, all code in the robot project has access to the enable/disable state, the overall robot teleop/auto/test mode, and the selected modes for teleop, auto, and test (even when the robot is disabled).

- Modes may be periodic or linear (or custom).  The Robot base class handles switching between modes and mode object instance creation.  Mode objects are constructed when the drop-down selection is made in the DS and run when the robot is enabled.

- The command-based framework provides convenience functions to link triggers to specific routines.  These triggers can then be linked to start specific commands (for auto modes).  To support multiple teleop modes, joystick bindings can be configured to only be active in specific routines.

## Driver Station

For reference, the FRC driver station is shown below.  This illustrates the enable/disable control (2) as well as the teleop/auto/practice/test selector (1).  For this design, "practice" is renamed to "match" for clarity.

![Driver Station GUI](https://docs.wpilib.org/en/stable/_images/ds-operation-tab.webp)

One or two drop-down selectors are added to this main screen.  One selector is displayed in teleop, auto, and test modes; two selectors (one for auto and one for teleop) is displayed in match mode (either manually selected by clicking "match," or when the DS is FMS-attached).

The drop-down lists have the modes (as defined by user code) organized into groups, similar to the below.  The groups and modes are sorted.

![Combo box with groups](https://i.sstatic.net/4Cmfk.gif)

Only the routines appropriate to the mode are shown in the corresponding list.  For example, if the "Test" option is selected, a single drop-down list with only test modes listed will be shown.

## Robot Code User-Facing API

Java is used for illustrative purposes.  Python and C++ should follow a similar structure, except that C++ doesn't support annotations.

### RobotBase

The `RobotBase` class is the base class for the user's `Robot` class.  It also implements the private library machinery for robot startup and robot execution (including creating and transitioning between modes in accordance with the mode lifecycle, as described in the following section).

```java
public abstract class RobotBase {
  public void disabledStart() {
    // this code is called when the robot enters disabled state (including at startup)
  }

  public void disabledPeriodic() {
    // this code is called periodically while the robot is disabled
  }

  public void disabledEnd() {
    // this code is called when the robot exits disabled state, prior to a mode starting
  }

  // these functions allow users to add modes without annotations
  public void addAutonomousMode(Supplier<Mode> factory, String name, String category, String description) {...}
  public void addTeleoperatedMode(Supplier<Mode> factory, String name, String category, String description) {...}
  public void addTestMode(Supplier<Mode> factory, String name, String category, String description) {...}
}
```

### Mode Classes

There are library base classes for different coding styles of routines.  The `Mode` interface serves as the base interface for all modes.  Most users will use either `LinearMode` or `PeriodicMode` abstract base class implementations of this interface, but this interface enables users to create more customized modes while still utilizing the core robot base class mode-switching implementation.

The full lifecycle of a mode is as follows:
- Operator selects mode on DS -> mode object is constructed
- If different mode is selected -> `close()` is called, object is released to GC
- While mode is selected and robot is disabled, `disabledPeriodic()` is called
- When the robot is enabled in the selected mode, `modeRun()` is called; the result of this is different for different mode base classes:
  - `start()` is called once (for both `LinearMode` and `PeriodicMode`)
  - `run()` is called (for `LinearMode`), or `periodic()` is called periodically (for `PeriodicMode`)
- When the robot is disabled, `modeStop()` is called (which results in `end()` being called for both `LinearMode` and `PeriodicMode`), followed by `close()`, object is released to GC

Following `close()` being called, a *new* mode object is constructed based on the DS teleop/auto/test/match selector and selected mode.  In teleop/auto/test, the drop-down selection will be the same as before the previous enable, so the same mode class is constructed again.  In match (or when FMS-connected), only the selected auto mode object is initially constructed; once auto completes, the selected teleop mode object is constructed.  Thus only zero or one mode objects will ever be "alive" at any given time.

For consistency in operation, the library will ensure that `disablePeriodic()` is always called at least once before `modeRun()` is called.

User implementations of mode classes may have either a no-parameter constructor or a constructor that accepts a class derived from `RobotBase`.  If available, the library will call the latter and pass the user's `Robot` object to it when constructing the class.

The library will use escalating steps to attempt to terminate a mode if `modeRun()` does not return within a reasonable timeframe after `modeStop()` is called, up to and including termination of the robot executable process (which will result in an automatic restart of it at the system level).

```java
public interface Mode extends AutoCloseable {
  // this function is called periodically while the mode is selected on the DS (robot is disabled)
  void disabledPeriodic();

  // void close(); // inherited from AutoCloseable

  // this function is called when the mode starts (robot is enabled)
  void modeRun();

  // this function is called asynchronously when the robot is disabled,
  // to request the mode return from modeRun()
  void modeStop();
}
```

```java
public abstract class LinearMode implements Mode {
  // the class is constructed when the mode is selected on the DS

  @Override
  public void disabledPeriodic() {
    // this code is called periodically while the mode is selected on the DS (robot is disabled)
  }

  @Override
  public void close() {
    // this code is called when the mode is de-selected on the DS
  }

  public void start() {
    // this code is called when the mode starts (robot is enabled)
  }

  public void run() {
    // this code is called once to run the mode (robot is enabled)
  }

  public void end() {
    // this code is called when the mode ends (robot is disabled)
  }

  // implements Mode interface
  @Override
  public void modeRun() {
    start();
    run();
    end();
  }

  @Override
  public void modeEnd() {
    // tries various things to "encourage" the run() function to return
  }
}
```

```java
public abstract class PeriodicMode implements Mode {
  // the class is constructed when the mode is selected on the DS

  // periodic modes may specify their period; if unspecified, a default period of 20 ms is used
  protected PeriodicMode() {...}
  protected PeriodicMode(double period) {...}

  @Override
  public void disabledPeriodic() {
    // this code is called periodically while the mode is selected on the DS (robot is disabled)
  }

  @Override
  public void close() {
    // this code is called when the mode is de-selected on the DS
  }

  public void start() {
    // this code is called when the mode starts (robot is enabled)
  }

  public void periodic() {
    // this code is called periodically while the mode is running (robot is enabled)
  }

  public void end() {
    // this code is called when the mode ends (robot is disabled)
  }

  // additional periodic functions can be added using these functions
  public final void addPeriodic(Runnable callback, double period) {...}
  public final void addPeriodic(Runnable callback, double period, double offset) {...}

  // returns the start time of the current loop
  public final double getLoopStartTime() {...}

  // implements Mode interface
  @Override
  public void modeRun() {
    // psuedo-code
    start();
    while (isRunning) {
      // wait for next periodic time
      // set loop start time
      periodic();  // or addPeriodic() callback, as appropriate
    }
    end();
  }

  @Override
  public void modeEnd() {
    // pseudo-code
    isRunning = false;
  }
}
```

### Annotations

All annotations are class-level.  All elements are optional and may be omitted.  If name is omitted, the class name is used.  If group is emitted, the mode is listed under a default group in the DS.  The description is blank if it is omitted.

```java
@Autonomous(String name, String group, String description)
@Teleoperated(String name, String group, String description)
@TestMode(String name, String group, String description)
```

Example use cases:

```java
// name will be "MyAuto", default group
@Autonomous
public class MyAuto extends ModeBaseClass {...}

// will use default group
@Teleoperated("my teleop")
public class MyTeleop extends ModeBaseClass {...}

@TestMode(name="my test", group="mechanisms", description="tests arm")
public class MyTest extends ModeBaseClass {...}
```

### DriverStation class

Note: the DriverStation class contains many other functions; only the mode-relevant functions are shown here.

```java
public final class DriverStation {
  // these return the enabled state;
  // the robot is always disabled when the DS is not connected
  public static boolean isEnabled() {...}
  public static boolean isDisabled() {...}

  // these return the overall robot mode;
  // they return false when the robot is disabled
  public static boolean isAutonomous() {...}
  public static boolean isTeleoperated() {...}
  public static boolean isTest() {...}

  // returns the current active mode;
  // returns "" when the robot is disabled
  public static String getActiveMode() {...}

  // these return the DS-selected modes;
  // these work when the robot is disabled, but return ""
  // if the DS is disconnected or no selection has been made
  public static String getSelectedAutonomousMode() {...}
  public static String getSelectedTeleoperatedMode() {...}
  public static String getSelectedTestMode() {...}

  // add/remove modes
  public static int addModeOption(String name, String category, String description, int flags) {...}
  public static int removeModeOption(String name) {...}
  public static void clearModeOptions() {...}
}
```

## Java Robot Code Examples (non-command-based)

Non-command-based robots will typically use classes to define routines.

The template/example code for non-command-based Java will include the following:
- Robot class
- A periodic autonomous mode
- A periodic teleop mode
- A linear test mode

Robot:

```java
public class Robot extends RobotBase {
  public final DifferentialDrive drive = new DifferentialDrive(...);

  public Robot() {}

  @Override
  public void disabledStart() {
    // this code is called when the robot enters disabled mode (including at startup)
  }

  @Override
  public void disabledPeriodic() {
    // this code is called periodically while the robot is disabled
  }

  @Override
  public void disabledEnd() {
    // this code is called when the robot exits disabled mode, prior to a routine starting
  }
}
```

Autonomous mode:

```java
@Autonomous(name="Drive straight", group="Drive")
public class AutoDriveStraight extends PeriodicMode {
  private final Robot robot;

  public AutoDriveStraight(Robot robot) {
    // the class is constructed when this mode is selected on the DS
    this.robot = robot;
  }

  @Override
  public void disabledPeriodic() {
    // this code is called periodically while the mode is selected on the DS (robot is disabled)
  }

  @Override
  public void close() {
    // this code is called when this mode is de-selected on the DS
  }

  @Override
  public void start() {
    // this code is called when the mode starts (robot is enabled)
  }

  @Override
  public void periodic() {
    // this code runs periodically while the mode is running (robot is enabled)
  }

  @Override
  public void end() {
    // this code is called when the mode ends (robot is disabled)
  }
}
```

Teleop mode:

```java
@Teleoperated
public class Teleop extends PeriodicMode {
  private final Joystick joy = new Joystick(1);
  private final Robot robot;

  public AutoDriveStraight(Robot robot) {
    this.robot = robot;
  }

  @Override
  public void periodic() {
    robot.drive.arcadeDrive(joy.getY(), joy.getX());
  }
}
```

Test mode:

```java
@TestMode("Blink dashboard indicator")
public class TestDashboardIndicator extends LinearMode {
  @Override
  public void run() {
    Telemetry.log("indicator", true);
    Timer.sleep(0.5);
    Telemetry.log("indicator", false);
  }
}
```

## Robot Code Command-Based Classes

Unlike the non-command-based approach, command-based generally favors a design where commands can be used in all modes and explicit periodic code is discouraged.  In addition, the general approach for "modern" commands eschews classes, preferring a "fluent" method chained builder approach.  To support this, mode registration for command-based is performed with function calls instead of separate annotated classes.

The command scheduler is run periodically in every command-based mode (including during the mode's disabledPeriodic).  The command scheduler runs a `periodic()` function in each command-based subsystem when it is run.

If the trigger-based approach is insufficient for a team's needs, a `PeriodicMode` class can also be used with the command scheduler being run from its `periodic()`.

### CommandModes

The `CommandModes` class provides factory functions for creating command-based modes.

```java
public final class CommandModes {
  // these register the mode and return a new CommandMode object for it
  // (also includes default versions so category and description are optional)
  public static CommandMode autonomousMode(String name, String category, String description) {...}
  public static CommandMode teleoperatedMode(String name, String category, String description) {...}
  public static CommandMode autonomousMode(String name, String category, String description) {...}
}
```

### CommandMode

The `CommandMode` class provides triggers to enable users to tie into each section of a mode's lifetime.  Triggers have the ability to be tied to specific commands or actions on both transitions (e.g. false to true, true to false) and while the condition is in a particular state.

```java
public class CommandMode {
  // mode is selected on DS (regardless of enabled or disabled)
  public final Trigger selected;

  // mode is selected, robot is disabled
  public final Trigger disabled;

  // mode is running, robot is enabled
  public final Trigger running;
}
```

## Java Robot Code Examples (command-based)

The template/example code for command-based Java includes the following:
- A Robot class with subsystems and constructor that sets up a command-based teleop mode, a couple of auto modes, and a test mode

Robot:

```java
public class Robot extends RobotBase {
  // subsystems
  public final Drive drive = new Drive();
  public final Intake intake = new Intake();
  public final Storage storage = new Storage();

  public Robot() {
    // create command bindings that are active in all command-based modes

    // Automatically disable and retract the intake whenever the ball storage is full.
    storage.hasCargo.onTrue(intake.retractCommand());

    // Add a couple of autonomous modes
    CommandModes.addAutonomous("Simple Auto").running.whileTrue(Autos.simpleAuto());

    var complexAuto = CommandModes.addAutonomous("Complex Auto", "Complex");
    complexAuto.selected.onTrue(Commands.runOnce(Paths::loadComplexPath));
    complexAuto.running.whileTrue(Autos.complexAuto());

    // Create a teleop mode with joystick and button controls
    var teleop = CommandModes.addTeleoperated("teleop");

    var driverController = new CommandXboxController(1);

    // Control the drive with split-stick arcade controls
    teleop.running.whileTrue(
        drive.arcadeDriveCommand(
            () -> -driverController.getLeftY(), () -> -driverController.getRightX()));

    // Deploy the intake with the X button
    teleop.running.and(driverController.x()).onTrue(intake.intakeCommand());
    // Retract the intake with the Y button
    teleop.running.and(driverController.y()).onTrue(intake.retractCommand());
  }
}
```

Autos:

```java
public class Autos {
  public static Command simpleAuto() {...}
  public static Command complexAuto() {...}
}
```

## C++ Robot Code

C++ does not support annotations, so explicit registration via `RobotBase` function calls is required.

## Python Robot Code

Should be able to be annotation (decorator) based, similar to Java.

## HAL

At the HAL level, Control Word bits indicate enabled state and teleop/auto/test selection (identical to current WPILib).  What needs to be added are functions to maintain the list of available modes and get the selected/active modes as communicated by the DS.

Adding the following functions provides all the required functionality:
- `int AddModeOption(string name, string category, string description, int flags)` – returns a unique ID identifying the mode (1:1 mapping to name).  Flags indicates which list the mode appears on.
- `int RemoveModeOption(string name)` – returns the unique ID previously associated to that mode name
ClearRoutines() – clears all modes
- `int GetActiveMode()` - gets the currently active mode ID; returns 0 when the robot is disabled
- `int GetSelectedAutonomousMode()` - gets the mode ID currently selected for autonomous; valid when the robot is disabled; returns 0 if unknown or no selection
- `int GetSelectedTeleoperatedMode()` - gets the mode ID currently selected for teleoperated; valid when the robot is disabled; returns 0 if unknown or no selection
- `int GetSelectedTestMode()` - gets the mode ID currently selected for test; valid when the robot is disabled; returns 0 if unknown or no selection

## DS Protocol

The list of modes (and details thereof) is communicated from the Robot to the DS via the tagged TCP link.

As in the current FRC protocol, the enabled state and teleop/auto/test selection are sent as part of the UDP control word from the DS to the Robot. Additionally, the selected modes for auto, teleop, and test are sent as part of every UDP packet.  This is done via a 64-bit hash of each mode's name.  Hash collisions are extremely low probability given the low quantity of modes, but this can be checked on the robot side when generating the mode list, and spaces appended as necessary to the provided names to uniquify the hashes.

# Drawbacks

# Alternatives

Use SendableChooser for more modes (teleop and test as well as autonomous); downsides of this:
- Doesn't allow flexibility of mixing linear and periodic modes
- Harder to use than annotations (generic class)
- No grouping, no filtering by mode (although these could be added)

# Trades

- Overall naming: mode? routine? opmode?

- Naming of mode functions? start-periodic-end, vs init-periodic-exit (2015 FRC PeriodicRobot), vs init-execute-end (2015 FRC Command), vs init-start-loop-stop (2015 FTC OpMode; note init behaves like the constructor here)

- For matches, should we construct teleop at the same time as auto?  If we do that, we probably need a disabledStart() or 2015 FTC opmode style init(), and don't run disabledPeriodic for both.

- Is it actually likely that team robots will have a mix of command-based modes and non-command-based?  If not, restricting command-based robots to *only* command-based modes might enable greater integration and ease-of-use for the typical command-based robot?

# Unresolved Questions

- FRC SendableChooser has a "default" option set by robot code.  Do we want something similar here or should it be 100% DS driven?  It's kind of nice to be able to set a default (e.g. via a `setDefaultAutonomousMode(String)` function in `Robot`), but also might be a little fragile since it's name based. If it's done via annotation, what happens if multiple annotations are marked as default?

- Should it be possible to have multiple top-level Robot classes (e.g. for different robot configurations), and have that be selectable at the DS as well?  This is a bit ugly to support even if when the Robot object is passed into the mode constructor, because different Robot class types will only work with certain modes.

- Python--will decorators be able to work similarly to Java annotations for mode registration?
